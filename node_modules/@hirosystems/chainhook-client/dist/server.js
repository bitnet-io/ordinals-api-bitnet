"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildServer = exports.BadPayloadRequestError = void 0;
const type_provider_typebox_1 = require("@fastify/type-provider-typebox");
const compiler_1 = require("@sinclair/typebox/compiler");
const fastify_1 = require("fastify");
const undici_1 = require("undici");
const logger_1 = require("./util/logger");
const helpers_1 = require("./util/helpers");
const payload_1 = require("./schemas/payload");
const predicate_1 = require("./schemas/predicate");
const if_this_1 = require("./schemas/bitcoin/if_this");
const if_this_2 = require("./schemas/stacks/if_this");
const ServerOptionsSchema = type_provider_typebox_1.Type.Object({
    hostname: type_provider_typebox_1.Type.String(),
    port: type_provider_typebox_1.Type.Integer(),
    auth_token: type_provider_typebox_1.Type.String(),
    external_base_url: type_provider_typebox_1.Type.String(),
    /** Wait for the chainhook node to be available before submitting predicates */
    wait_for_chainhook_node: type_provider_typebox_1.Type.Optional(type_provider_typebox_1.Type.Boolean({ default: true })),
    /** Validate the JSON schema of received chainhook payloads and report errors when invalid */
    validate_chainhook_payloads: type_provider_typebox_1.Type.Optional(type_provider_typebox_1.Type.Boolean({ default: false })),
    /** Size limit for received chainhook payloads (default 40MB) */
    body_limit: type_provider_typebox_1.Type.Optional(type_provider_typebox_1.Type.Number({ default: 41943040 })),
    /** Node type: `chainhook` or `ordhook` */
    node_type: type_provider_typebox_1.Type.Optional(type_provider_typebox_1.Type.Union([type_provider_typebox_1.Type.Literal('chainhook'), type_provider_typebox_1.Type.Literal('ordhook')], {
        default: 'chainhook',
    })),
});
const ChainhookNodeOptionsSchema = type_provider_typebox_1.Type.Object({
    base_url: type_provider_typebox_1.Type.String(),
});
/**
 * Throw this error when processing a Chainhook Payload if you believe it is a bad request. This
 * will cause the server to return a `400` status code.
 */
class BadPayloadRequestError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}
exports.BadPayloadRequestError = BadPayloadRequestError;
const IfThisThenNothingSchema = type_provider_typebox_1.Type.Union([
    type_provider_typebox_1.Type.Composite([
        if_this_1.BitcoinIfThisOptionsSchema,
        type_provider_typebox_1.Type.Object({
            if_this: if_this_1.BitcoinIfThisSchema,
        }),
    ]),
    type_provider_typebox_1.Type.Composite([
        if_this_2.StacksIfThisOptionsSchema,
        type_provider_typebox_1.Type.Object({
            if_this: if_this_2.StacksIfThisSchema,
        }),
    ]),
]);
const ServerPredicateSchema = type_provider_typebox_1.Type.Composite([
    predicate_1.PredicateHeaderSchema,
    type_provider_typebox_1.Type.Object({
        networks: type_provider_typebox_1.Type.Union([
            type_provider_typebox_1.Type.Object({
                mainnet: IfThisThenNothingSchema,
            }),
            type_provider_typebox_1.Type.Object({
                testnet: IfThisThenNothingSchema,
            }),
        ]),
    }),
]);
/**
 * Build the Chainhook Fastify event server.
 * @param serverOpts - Server options
 * @param chainhookOpts - Chainhook node options
 * @param predicates - Predicates to register
 * @param callback - Event callback function
 * @returns Fastify instance
 */
async function buildServer(serverOpts, chainhookOpts, predicates, callback) {
    async function waitForNode() {
        logger_1.logger.info(`ChainhookEventObserver connecting to chainhook node at ${chainhookOpts.base_url}...`);
        while (true) {
            try {
                await (0, undici_1.request)(`${chainhookOpts.base_url}/ping`, { method: 'GET', throwOnError: true });
                break;
            }
            catch (error) {
                logger_1.logger.error(error, 'Chainhook node not available, retrying...');
                await (0, helpers_1.timeout)(1000);
            }
        }
    }
    async function registerPredicates() {
        if (predicates.length === 0) {
            logger_1.logger.info(`ChainhookEventObserver does not have predicates to register`);
            return;
        }
        const nodeType = serverOpts.node_type ?? 'chainhook';
        const path = nodeType === 'chainhook' ? `/v1/chainhooks` : `/v1/observers`;
        const registerUrl = `${chainhookOpts.base_url}${path}`;
        logger_1.logger.info(predicates, `ChainhookEventObserver registering predicates at ${registerUrl}`);
        for (const predicate of predicates) {
            const thenThat = {
                http_post: {
                    url: `${serverOpts.external_base_url}/payload`,
                    authorization_header: `Bearer ${serverOpts.auth_token}`,
                },
            };
            try {
                const body = predicate;
                if ('mainnet' in body.networks)
                    body.networks.mainnet.then_that = thenThat;
                if ('testnet' in body.networks)
                    body.networks.testnet.then_that = thenThat;
                await (0, undici_1.request)(registerUrl, {
                    method: 'POST',
                    body: JSON.stringify(body),
                    headers: { 'content-type': 'application/json' },
                    throwOnError: true,
                });
                logger_1.logger.info(`ChainhookEventObserver registered '${predicate.name}' predicate (${predicate.uuid})`);
            }
            catch (error) {
                logger_1.logger.error(error, `ChainhookEventObserver unable to register predicate`);
            }
        }
    }
    async function removePredicates() {
        if (predicates.length === 0) {
            logger_1.logger.info(`ChainhookEventObserver does not have predicates to close`);
            return;
        }
        logger_1.logger.info(`ChainhookEventObserver closing predicates at ${chainhookOpts.base_url}`);
        const nodeType = serverOpts.node_type ?? 'chainhook';
        const removals = predicates.map(predicate => new Promise((resolve, reject) => {
            const path = nodeType === 'chainhook'
                ? `/v1/chainhooks/${predicate.chain}/${encodeURIComponent(predicate.uuid)}`
                : `/v1/observers/${encodeURIComponent(predicate.uuid)}`;
            (0, undici_1.request)(`${chainhookOpts.base_url}${path}`, {
                method: 'DELETE',
                headers: { 'content-type': 'application/json' },
                throwOnError: true,
            })
                .then(() => {
                logger_1.logger.info(`ChainhookEventObserver removed '${predicate.name}' predicate (${predicate.uuid})`);
                resolve();
            })
                .catch(error => {
                logger_1.logger.error(error, `ChainhookEventObserver unable to deregister predicate`);
                reject(error);
            });
        }));
        await Promise.allSettled(removals);
    }
    async function isEventAuthorized(request, reply) {
        const authHeader = request.headers.authorization;
        if (authHeader && authHeader === `Bearer ${serverOpts.auth_token}`) {
            return;
        }
        await reply.code(403).send();
    }
    const ChainhookEventObserver = (fastify, options, done) => {
        const compiledPayloadSchema = compiler_1.TypeCompiler.Compile(payload_1.PayloadSchema);
        fastify.addHook('preHandler', isEventAuthorized);
        fastify.post('/payload', {
            schema: {
                body: payload_1.PayloadSchema,
            },
        }, async (request, reply) => {
            if ((serverOpts.validate_chainhook_payloads ?? false) &&
                !compiledPayloadSchema.Check(request.body)) {
                logger_1.logger.error([...compiledPayloadSchema.Errors(request.body)], `ChainhookEventObserver received an invalid payload`);
                await reply.code(422).send();
                return;
            }
            try {
                await callback(request.body.chainhook.uuid, request.body);
                await reply.code(200).send();
            }
            catch (error) {
                if (error instanceof BadPayloadRequestError) {
                    logger_1.logger.error(error, `ChainhookEventObserver bad payload`);
                    await reply.code(400).send();
                }
                else {
                    logger_1.logger.error(error, `ChainhookEventObserver error processing payload`);
                    await reply.code(500).send();
                }
            }
        });
        done();
    };
    const fastify = (0, fastify_1.default)({
        trustProxy: true,
        logger: logger_1.PINO_CONFIG,
        pluginTimeout: 0,
        bodyLimit: serverOpts.body_limit ?? 41943040, // 40MB default
    }).withTypeProvider();
    if (serverOpts.wait_for_chainhook_node ?? true) {
        fastify.addHook('onReady', waitForNode);
    }
    fastify.addHook('onReady', registerPredicates);
    fastify.addHook('onClose', removePredicates);
    await fastify.register(ChainhookEventObserver);
    return fastify;
}
exports.buildServer = buildServer;
//# sourceMappingURL=server.js.map