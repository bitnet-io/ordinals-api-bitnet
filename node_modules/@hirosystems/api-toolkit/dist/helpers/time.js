"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waiter = exports.stopwatch = exports.resolveOrTimeout = exports.time = exports.timeout = void 0;
/**
 * Wait a set amount of milliseconds or until the timer is aborted.
 * @param ms - Number of milliseconds to wait
 * @param abortController - Abort controller
 * @returns Promise
 */
function timeout(ms, abortController) {
    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            resolve();
        }, ms);
        abortController?.signal.addEventListener('abort', () => {
            clearTimeout(timeout);
            reject(new Error(`Timeout aborted`));
        }, { once: true });
    });
}
exports.timeout = timeout;
/**
 * Time the execution of an async function.
 * @param fn - Async function
 * @param onFinish - Callback with elapsed milliseconds
 * @returns Promise
 */
async function time(fn, onFinish) {
    const watch = stopwatch();
    try {
        return await fn();
    }
    finally {
        onFinish(watch.getElapsed());
    }
}
exports.time = time;
/**
 * Set an execution time limit for a promise.
 * @param promise - The promise being capped to `timeoutMs` max execution time
 * @param timeoutMs - Timeout limit in milliseconds
 * @param wait - If we should wait another `timeoutMs` period for `promise` to resolve
 * @param waitHandler - If `wait` is `true`, this closure will be executed before waiting another
 * `timeoutMs` cycle
 * @returns `true` if `promise` ended gracefully, `false` if timeout was reached
 */
async function resolveOrTimeout(promise, timeoutMs, wait = false, waitHandler) {
    let timer;
    const result = await Promise.race([
        new Promise((resolve, reject) => {
            promise
                .then(() => resolve(true))
                .catch(error => reject(error))
                .finally(() => clearTimeout(timer));
        }),
        new Promise((resolve, _) => {
            timer = setInterval(() => {
                if (!wait) {
                    clearTimeout(timer);
                    resolve(false);
                    return;
                }
                if (waitHandler) {
                    waitHandler();
                }
            }, timeoutMs);
        }),
    ]);
    return result;
}
exports.resolveOrTimeout = resolveOrTimeout;
/**
 * Start a `Stopwatch` that measures elapsed time based on `process.hrtime`.
 * @returns Stopwatch
 */
function stopwatch() {
    let start = process.hrtime.bigint();
    const result = {
        getElapsedSeconds: () => {
            const elapsedMs = result.getElapsed();
            return elapsedMs / 1000;
        },
        getElapsed: () => {
            const end = process.hrtime.bigint();
            return Number((end - start) / 1000000n);
        },
        getElapsedAndRestart: () => {
            const end = process.hrtime.bigint();
            const result = Number((end - start) / 1000000n);
            start = process.hrtime.bigint();
            return result;
        },
        restart: () => {
            start = process.hrtime.bigint();
        },
    };
    return result;
}
exports.stopwatch = stopwatch;
/**
 * Creates a `Waiter` promise that can be resolved at a later time with a return value.
 * @returns Waiter
 */
function waiter() {
    let resolveFn;
    const promise = new Promise(resolve => {
        resolveFn = resolve;
    });
    const completer = {
        finish: (result) => {
            completer.isFinished = true;
            resolveFn(result);
        },
        isFinished: false,
    };
    return Object.assign(promise, completer);
}
exports.waiter = waiter;
//# sourceMappingURL=time.js.map