/// <reference types="node" />
/**
 * Wait a set amount of milliseconds or until the timer is aborted.
 * @param ms - Number of milliseconds to wait
 * @param abortController - Abort controller
 * @returns Promise
 */
export declare function timeout(ms: number, abortController?: AbortController): Promise<void>;
/**
 * Time the execution of an async function.
 * @param fn - Async function
 * @param onFinish - Callback with elapsed milliseconds
 * @returns Promise
 */
export declare function time<T>(fn: () => Promise<T>, onFinish: (elapsedMs: number) => void): Promise<T>;
/**
 * Set an execution time limit for a promise.
 * @param promise - The promise being capped to `timeoutMs` max execution time
 * @param timeoutMs - Timeout limit in milliseconds
 * @param wait - If we should wait another `timeoutMs` period for `promise` to resolve
 * @param waitHandler - If `wait` is `true`, this closure will be executed before waiting another
 * `timeoutMs` cycle
 * @returns `true` if `promise` ended gracefully, `false` if timeout was reached
 */
export declare function resolveOrTimeout(promise: Promise<void>, timeoutMs: number, wait?: boolean, waitHandler?: () => void): Promise<unknown>;
export interface Stopwatch {
    /** Milliseconds since stopwatch was created. */
    getElapsed: () => number;
    /** Seconds since stopwatch was created. */
    getElapsedSeconds: () => number;
    getElapsedAndRestart: () => number;
    restart(): void;
}
/**
 * Start a `Stopwatch` that measures elapsed time based on `process.hrtime`.
 * @returns Stopwatch
 */
export declare function stopwatch(): Stopwatch;
export type Waiter<T> = Promise<T> & {
    finish: (result: T) => void;
    isFinished: boolean;
};
/**
 * Creates a `Waiter` promise that can be resolved at a later time with a return value.
 * @returns Waiter
 */
export declare function waiter<T = void>(): Waiter<T>;
